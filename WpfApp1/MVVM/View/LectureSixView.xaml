<UserControl x:Class="ComputerGraphics.MVVM.View.LectureSixView"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006" 
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008" 
             xmlns:local="clr-namespace:ComputerGraphics.MVVM.View"
             mc:Ignorable="d" 
             d:DesignHeight="450" d:DesignWidth="800">
    <Grid>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="400"/>
            <ColumnDefinition Width="400"/>
        </Grid.ColumnDefinitions>

        <Grid.RowDefinitions>
            <RowDefinition Height="10"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <ScrollViewer Grid.Row="0" Grid.RowSpan="2"
                      Margin="0,0,-30,0" VerticalScrollBarVisibility="Hidden">

            <StackPanel VerticalAlignment="Top" >

                <TextBlock HorizontalAlignment="Left" Grid.Row="0" Grid.Column="0"
                   Text="OREZÁVANIE ÚSEČKY A TEXTU"  FontWeight="Bold" FontSize="20" Foreground="#FF424242"/>

                <TextBlock HorizontalAlignment="Left" Grid.Row="0" Grid.Column="0"
                   Text="BOD"  FontWeight="Bold"  FontSize="16" Foreground="#FF424242"
                           Margin="25,0,0,-20"/>

                <TextBlock HorizontalAlignment="Left" 
                   Grid.Row="0" Grid.Column="0"
                   Margin="10,30,0,0"
                   Text="Pri orezávaní úsečky potrebujeme viac porovnávaní a výpočtov ako pre bod.
Niektoré prípady sa dajú ľahko vylúčiť: 
&#x0a;Ak koncové body úsečky ležia vo vnútri okna, potom sa celá úsečka vykresľuje.
&#x0a;Ak koncové body úsečky ležia mimo okna, potom je nutné overiť, či sa úsečka pretína
s oknom – ak áno, je nutné ju orezávať.
&#x0a;&#x0a;Jeden z možných spôsobov orezávania je vyhľadanie bodov prieniku úsečky s úsečkami,
ktoré tvoria okno. &#x0a;Vylúčiť z orezávania môžeme aj úsečky:
Vylúčiť z orezávania môžeme aj úsečky:
&#x0a;1. ak ich koncové body majú y > ymax (úsečka leží nad oknom)
&#x0a;2. ak ich koncové body majú y &lt; ymin (úsečka leží pod oknom)
&#x0a;3. ak ich koncové body majú x &lt; xmin (úsečka leží naľavo od okna)
&#x0a;4. ak ich koncové body majú x > xmax (úsečka leží napravo od okna)"
                   TextWrapping="Wrap"
                   FontSize="12" Foreground="#FF424242"/>

                <!-- COHEN -->
                <Expander IsExpanded="False" 
                  Grid.Row="0" Grid.Column="0"
                  Grid.RowSpan="2"
                  Background="Transparent" Header="ALGORITMUS COHENA - SUTHERLANDA"
                  Foreground="#FF424242" FontSize="12" FontWeight="Bold"
                  Cursor="Hand">
                    <StackPanel>
                        <TextBlock  TextWrapping="Wrap"
                            FontWeight="Normal"
                            Foreground="#FF424242"
                            FontSize="12"
                            Cursor="Arrow"
                            Text="Tento algoritmus rýchlo vylúči predchádzajúce prípady. Preto je zvlášť rýchly v prípade, ak je
veľké okno a obsahuje veľa úsečiek vo vnútri, alebo ak je malé okno a väčšina úsečiek je
mimo okna. V týchto prípadoch sa úsečka podľa potreby buď celá zobrazí alebo nezobrazí "/>
                        <TextBlock  TextWrapping="Wrap"
                            FontWeight="Normal"
                            Foreground="#FF424242"
                            FontSize="12"
                            FontStyle="Italic"
                            Cursor="Arrow"
                            Text="Algoritmus:"/>
                        <TextBlock  TextWrapping="Wrap"
                            FontWeight="Normal"
                            Foreground="#FF424242"
                            FontSize="12"
                            Cursor="Arrow"
                            Text="&#x0a;Na začiatku algoritmus nastaví 4-bitové hodnoty pre oba koncové body úsečky podľa ich polôh vzhľadom na okno.
&#x0a;Hodnota bitov sa určuje porovnaním súradníc bodu (x, y) s hranicou okna
&#x0a;1. bit je nastavený na 1, ak bod leží vyššie od okna (y > ymax )
&#x0a;2. bit je nastavený na 1, ak bod leží nižšie od okna (y &lt; ymin )
&#x0a;3. bit je nastavený na 1, ak bod leží napravo od okna (x > xmax )
&#x0a;4. bit je nastavený na 1, ak bod leží naľavo od okna (x &lt; xmin )
&#x0a;inak sú bity nastavené na 0. &#x0a;"/>

                        <Image Source="/Images/cohenalg.png" 
                                Height="125"
                                HorizontalAlignment="Center" VerticalAlignment="Center"
                               Cursor="Arrow"/>

                        <TextBlock  TextWrapping="Wrap"
                            FontWeight="Normal"
                            Foreground="#FF424242"
                            FontSize="12"
                            FontStyle="Italic"
                            Cursor="Arrow"
                            Text="&#x0a;Bod sa nachádza vo vnútri okna, ak jeho kód je rovný 0000.
&#x0a;Ak oba koncové body majú kód 0000 – úsečka je vo vnútri okna, t. j. vykreslíme ju.
&#x0a;Ak sú oba koncové body nad, pod, vľavo alebo vpravo od okna, potom je celá úsečka
mimo okna a ľahko sa identifikuje podľa nastavených bitov kódu koncových bodov,
pretože je nastavený bit na rovnakom mieste.
&#x0a;V týchto prípadoch stačí pre body overiť, či logický súčin ich kódov je rôzny od 0000.
Ak áno, tak úsečku vylúčime z orezávania.
&#x0a;Ak je logický súčin 0000, tak úsečku nemôžeme vylúčiť, pretože ešte môže mať prienik
s oknom. Tieto úsečky môžu, ale nemusia prechádzať vnútrom okna "/>

                    </StackPanel>
                </Expander>

                <!-- POSTUP DELENIE -->
                <Expander IsExpanded="False" 
                  Grid.Row="0" Grid.Column="0"
                  Grid.RowSpan="2"
                  Background="Transparent" Header="ALGORITMUS POSTUPNÉHO DELENIA"
                  Foreground="#FF424242" FontSize="12" FontWeight="Bold"
                  Cursor="Hand">
                    <StackPanel>
                        <TextBlock  TextWrapping="Wrap"
                            FontWeight="Normal"
                            Foreground="#FF424242"
                            FontSize="12"
                            Cursor="Arrow"
                            Text="Ak nechceme pri hľadaní priesečníkov úsečky s oknom počítať s rovnicami priamok, môžeme použiť algoritmus postupného delenia:
&#x0a;Pre koncové body úsečky vypočítame ich 4-bitové kódy.
&#x0a;Vylúčime úsečky z orezávania.
&#x0a;Tie úsečky, ktoré nie sú vylúčené z orezávania, budú vyšetrované pomocou výpočtu súradníc stredu úsečky.
&#x0a;Súradnice stredu úsečky ľahko vypočítame: "/>
                        <TextBlock  TextWrapping="Wrap"
                            FontWeight="Normal"
                            Foreground="#FF424242"
                            FontSize="12"
                            FontStyle="Italic"
                            Cursor="Arrow"
                            Text="(Xs, Ys) = ((X1 + X2) / 2, (Y1 + Y2) / 2)"/>
                        <TextBlock  TextWrapping="Wrap"
                            FontWeight="Normal"
                            Foreground="#FF424242"
                            FontSize="12"
                            Cursor="Arrow"
                            Text="Pre každú časť úsečky overujeme, či ju nemôžeme vylúčiť z orezávania podľa kritéria, či leží nad alebo pod oknom, vľavo alebo vpravo od okna alebo v okne.
&#x0a;Ak jednu časť vylúčime, pokračujeme v delení pre tú časť, ktorá sa vylúčiť nedala.
&#x0a;Ak sa nedá vylúčiť ani jedna polovica, potom dočasne odložíme jednu časť a poukončení práce s druhou sa k nej vrátime.
&#x0a;Stratégia spočíva v opakovaní delenia úsečky na polovicu dovtedy, pokiaľ sa jeden segment nebude celý zobrazovať (v prípade, že stred leží na hranici okna) a druhý sacelý vylúči."/>
                        
                    </StackPanel>
                </Expander>

                <TextBlock HorizontalAlignment="Left" Grid.Row="0" Grid.Column="0"
                           Text="TEXT" FontWeight="Bold" FontSize="16" Foreground="#FF424242"
                           Margin="25,0,0,-20"/>

                <TextBlock HorizontalAlignment="Left" 
                   Grid.Row="0" Grid.Column="0"
                   Margin="10,30,0,0"
                   Text="Text je možné orezávať niekoľkými spôsobmi:
&#x0a;1. Každé písmeno orezávame podľa úsečiek, ktoré ho vytvárajú. Dostaneme tak presné zobrazenie textu v okne, ale na úkor času. &#x0a;2. Pre každý znak vytvoríme obálku znaku – minimálny obdĺžnik, v ktorom je znak
obsiahnutý:
&#x0a;a) vezmeme stred obálky ako referenčný bod – ak leží v okne, potom znak vykreslíme,
inak znak nevykreslíme
&#x0a;b) ak celá obálka leží v okne, potom znak vykreslíme, inak znak nevykreslíme
&#x0a;3. Vytvoríme obálku pre každé slovo alebo riadok:
&#x0a;v takomto prípade sa buď celé slovo alebo celý riadok zobrazí alebo nie,
&#x0a;za kritérium si môžeme vybrať, či stred slova alebo riadku leží v okne alebo nie, alebo
či celá obálka slova alebo riadku leží v okne alebo nie."
                   TextWrapping="Wrap"
                   FontSize="12" Foreground="#FF424242"/>

            </StackPanel>
        </ScrollViewer>

    </Grid>
</UserControl>
